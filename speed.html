<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Airspeed Indicator Style Meter</title>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap');
        
        body {
            font-family: 'Share Tech Mono', monospace;
        }

        .needle {
            transition: transform 0.5s cubic-bezier(0.4, 0.0, 0.2, 1);
            transform-origin: center;
        }
        
        .value-text {
            transition: all 0.2s;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-900 min-h-screen flex flex-col items-center justify-center p-4">

    <!-- Container -->
    <div class="relative w-full max-w-md flex flex-col items-center space-y-8">
        
        <!-- Header -->
        <h1 class="text-2xl text-gray-600 uppercase tracking-widest font-bold">Ground Speed</h1>

        <!-- Meter Component -->
        <div class="relative w-80 h-80 bg-white rounded-full shadow-xl border-8 border-gray-200 p-2">
            <!-- Inner Bezel -->
            <div class="w-full h-full rounded-full bg-white relative overflow-hidden shadow-[inset_0_0_20px_rgba(0,0,0,0.1)]">
                
                <!-- SVG Gauge -->
                <svg viewBox="0 0 200 200" class="w-full h-full absolute top-0 left-0">
                    <!-- Ticks will be generated by JS -->
                    <g id="ticks-container"></g>
                    
                    <!-- Needle -->
                    <g id="needle-group" class="needle" style="transform: rotate(-135deg);">
                        <path d="M 100 100 L 100 20 L 105 100 Z" fill="#ef4444"/> <!-- Long part -->
                        <path d="M 100 100 L 95 100 L 100 20 Z" fill="#b91c1c"/> <!-- Shading -->
                        <circle cx="100" cy="100" r="5" fill="#333"/>
                    </g>
                </svg>

                <!-- Digital Readout -->
                <div class="absolute bottom-12 left-1/2 transform -translate-x-1/2 text-center">
                    <div class="bg-gray-100 border-2 border-gray-300 rounded px-3 py-1 shadow-inner">
                        <div id="digital-value" class="text-3xl font-bold text-gray-800 font-mono">000</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Controls -->
        <div class="w-full bg-white p-4 rounded-lg border border-gray-200 shadow-md">
            <h2 class="text-sm text-gray-500 mb-2 uppercase font-bold">Data Input (JSON)</h2>
            <div class="flex space-x-2 mb-2">
                <textarea id="json-input" class="w-full bg-gray-50 text-gray-800 font-mono text-sm p-2 rounded border border-gray-300 focus:outline-none focus:border-blue-500 h-24" placeholder='{ "speed": 45 }'></textarea>
            </div>
            <div class="flex space-x-2">
                <button onclick="updateFromInput()" class="flex-1 bg-blue-600 hover:bg-blue-500 text-white py-2 rounded transition font-bold text-sm uppercase">Update Meter</button>
                <button onclick="simulateData()" class="flex-1 bg-gray-200 hover:bg-gray-300 text-gray-700 py-2 rounded transition font-bold text-sm uppercase">Auto Demo</button>
            </div>
            <p id="status-msg" class="text-xs mt-2 text-gray-500 h-4"></p>
        </div>

    </div>

    <script>
        // Configuration
        const MIN_VAL = 0;
        const MAX_VAL = 100;
        const START_ANGLE = -135; // degrees (bottom left)
        const END_ANGLE = 135;   // degrees (bottom right)
        
        // DOM Elements
        const needleGroup = document.getElementById('needle-group');
        const digitalValue = document.getElementById('digital-value');
        const ticksContainer = document.getElementById('ticks-container');
        const jsonInput = document.getElementById('json-input');
        const statusMsg = document.getElementById('status-msg');

        let simulationInterval = null;

        // Helper functions for SVG Arcs
        function polarToCartesian(centerX, centerY, radius, angleInDegrees) {
            var angleInRadians = (angleInDegrees - 90) * Math.PI / 180.0;
            return {
                x: centerX + (radius * Math.cos(angleInRadians)),
                y: centerY + (radius * Math.sin(angleInRadians))
            };
        }

        function describeArc(x, y, radius, startAngle, endAngle) {
            var start = polarToCartesian(x, y, radius, endAngle);
            var end = polarToCartesian(x, y, radius, startAngle);
            var largeArcFlag = endAngle - startAngle <= 180 ? "0" : "1";
            var d = [
                "M", start.x, start.y, 
                "A", radius, radius, 0, largeArcFlag, 0, end.x, end.y
            ].join(" ");
            return d;
        }

        // Initialize Gauge Graphics
        function initGauge() {
            const radius = 80;
            const center = 100;
            const totalRange = MAX_VAL - MIN_VAL;
            const angleRange = END_ANGLE - START_ANGLE;
            
            ticksContainer.innerHTML = ""; // Clear previous

            // Helper to add colored arc
            function addArc(startVal, endVal, color, width) {
                const startNorm = (startVal - MIN_VAL) / totalRange;
                const endNorm = (endVal - MIN_VAL) / totalRange;
                
                const startDeg = START_ANGLE + (startNorm * angleRange);
                const endDeg = START_ANGLE + (endNorm * angleRange);
                
                const pathStr = describeArc(center, center, radius, startDeg, endDeg);
                const pathEl = document.createElementNS("http://www.w3.org/2000/svg", "path");
                pathEl.setAttribute("d", pathStr);
                pathEl.setAttribute("fill", "none");
                pathEl.setAttribute("stroke", color);
                pathEl.setAttribute("stroke-width", width);
                pathEl.setAttribute("stroke-linecap", "butt"); 
                ticksContainer.appendChild(pathEl);
            }

            // 1. Green Arc 0-60
            addArc(0, 60, "#22c55e", 10); 

            // 2. Red Arc 60-100
            addArc(60, 100, "#ef4444", 10);

            // 3. White Arc 20-40 (inside green)
            addArc(20, 40, "#ffffff", 4);

            // Generate Ticks (Major only)
            for (let i = MIN_VAL; i <= MAX_VAL; i+=2) { 
                const isMajor = i % 10 === 0;
                if (!isMajor) continue;

                const normalizedValue = (i - MIN_VAL) / totalRange;
                const angleDeg = START_ANGLE + (normalizedValue * angleRange);
                const angleRad = (angleDeg - 90) * (Math.PI / 180);

                const tickLength = 12;
                // Move ticks slightly inward relative to the arcs so they are visible or align nicely
                const outerR = radius + 2;
                const innerR = radius - 10;

                const x1 = center + outerR * Math.cos(angleRad);
                const y1 = center + outerR * Math.sin(angleRad);
                const x2 = center + innerR * Math.cos(angleRad);
                const y2 = center + innerR * Math.sin(angleRad);

                const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                line.setAttribute("x1", x1);
                line.setAttribute("y1", y1);
                line.setAttribute("x2", x2);
                line.setAttribute("y2", y2);
                line.setAttribute("stroke", "black");
                line.setAttribute("stroke-width", "3");
                ticksContainer.appendChild(line);

                // Add numbers for major ticks (only for 0, 20, 40, 60, 80, 100)
                if (i % 20 === 0) {
                    const textR = radius - 25;
                    const tx = center + textR * Math.cos(angleRad);
                    const ty = center + textR * Math.sin(angleRad);
                    
                    const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
                    text.setAttribute("x", tx);
                    text.setAttribute("y", ty);
                    text.setAttribute("fill", "black");
                    text.setAttribute("font-size", "16"); 
                    text.setAttribute("font-weight", "bold");
                    text.setAttribute("font-family", "'Share Tech Mono', monospace");
                    text.setAttribute("text-anchor", "middle");
                    text.setAttribute("dominant-baseline", "central");
                    text.textContent = i;
                    
                    ticksContainer.appendChild(text);
                }
            }
        }

        // Update Gauge Function
        function setGaugeValue(val) {
            // Clamp value
            let value = Math.max(MIN_VAL, Math.min(MAX_VAL, val));
            
            // Calculate angle
            const totalRange = MAX_VAL - MIN_VAL;
            const angleRange = END_ANGLE - START_ANGLE;
            const normalizedValue = (value - MIN_VAL) / totalRange;
            const angleDeg = START_ANGLE + (normalizedValue * angleRange);

            // Rotate needle
            needleGroup.style.transform = `rotate(${angleDeg}deg)`;

            // Update digital text
            // Pad with zeros if needed, e.g., 005
            // But aircraft digital readouts might just be the number. Let's do standard number.
            digitalValue.textContent = Math.round(value).toString().padStart(3, '0');
        }

        // Handle JSON Input
        function updateFromInput() {
            stopSimulation();
            const raw = jsonInput.value;
            try {
                const data = JSON.parse(raw);
                // Look for common keys: value, speed, knots, or just a number
                let val = null;
                if (typeof data === 'number') {
                    val = data;
                } else if (typeof data === 'object') {
                    if (data.value !== undefined) val = data.value;
                    else if (data.speed !== undefined) val = data.speed;
                    else if (data.knots !== undefined) val = data.knots;
                }

                if (val !== null) {
                    setGaugeValue(Number(val));
                    statusMsg.textContent = "Updated successfully.";
                    statusMsg.className = "text-xs mt-2 text-green-500 h-4";
                } else {
                    throw new Error("Could not find 'speed', 'value', or 'knots' in JSON.");
                }
            } catch (e) {
                statusMsg.textContent = "Error: " + e.message;
                statusMsg.className = "text-xs mt-2 text-red-500 h-4";
            }
        }

        // Simulation
        function simulateData() {
            if (simulationInterval) return;
            statusMsg.textContent = "Demo mode active...";
            statusMsg.className = "text-xs mt-2 text-blue-400 h-4";
            
            let currentVal = 0;
            let targetVal = 50;

            simulationInterval = setInterval(() => {
                // Random walk
                if (Math.random() > 0.95) {
                    targetVal = Math.random() * 100;
                }
                
                // Smooth approach
                currentVal += (targetVal - currentVal) * 0.1;
                
                setGaugeValue(currentVal);
                
                // Update input box to show what's happening (optional)
                // jsonInput.value = JSON.stringify({ speed: Math.round(currentVal) }, null, 2); 
            }, 100);
        }

        function stopSimulation() {
            if (simulationInterval) {
                clearInterval(simulationInterval);
                simulationInterval = null;
                statusMsg.textContent = "";
            }
        }

        // Initialize
        initGauge();
        setGaugeValue(0);
        jsonInput.value = JSON.stringify({ speed: 45 }, null, 2);

    </script>
</body>
</html>
